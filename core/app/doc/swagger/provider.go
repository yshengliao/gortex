package swagger

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/yshengliao/gortex/core/app/doc"
)

// SwaggerProvider implements the DocProvider interface for Swagger/OpenAPI 3.0
type SwaggerProvider struct {
	config       *doc.DocConfig
	swagger      *OpenAPI
	swaggerJSON  []byte
	uiHandler    http.Handler
}

// NewSwaggerProvider creates a new Swagger documentation provider
func NewSwaggerProvider(config *doc.DocConfig) *SwaggerProvider {
	if config == nil {
		config = &doc.DocConfig{
			Title:       "API Documentation",
			Version:     "1.0.0",
			Description: "API documentation generated by Gortex",
		}
	}

	swagger := &OpenAPI{
		OpenAPI: "3.0.3",
		Info: Info{
			Title:       config.Title,
			Version:     config.Version,
			Description: config.Description,
		},
		Servers: make([]Server, 0),
		Paths:   make(map[string]*PathItem),
		Components: &Components{
			Schemas:         make(map[string]*Schema),
			SecuritySchemes: make(map[string]*SecurityScheme),
		},
	}

	// Add servers from config
	for _, srv := range config.Servers {
		swagger.Servers = append(swagger.Servers, Server{
			URL:         srv.URL,
			Description: srv.Description,
		})
	}

	// Add contact info if provided
	if config.Contact != nil {
		swagger.Info.Contact = &Contact{
			Name:  config.Contact.Name,
			Email: config.Contact.Email,
			URL:   config.Contact.URL,
		}
	}

	// Add license info if provided
	if config.License != nil {
		swagger.Info.License = &License{
			Name: config.License.Name,
			URL:  config.License.URL,
		}
	}

	return &SwaggerProvider{
		config:  config,
		swagger: swagger,
	}
}

// Generate creates the Swagger documentation from routes
func (p *SwaggerProvider) Generate(routes []doc.RouteInfo) ([]byte, error) {
	// Clear existing paths
	p.swagger.Paths = make(map[string]*PathItem)

	// Process each route
	for _, route := range routes {
		p.addRoute(route)
	}

	// Generate common schemas
	p.generateCommonSchemas()

	// Convert to JSON
	data, err := json.MarshalIndent(p.swagger, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("failed to marshal swagger: %w", err)
	}

	p.swaggerJSON = data
	return data, nil
}

// ContentType returns the MIME type for Swagger JSON
func (p *SwaggerProvider) ContentType() string {
	return "application/json"
}

// UIHandler returns the Swagger UI handler
func (p *SwaggerProvider) UIHandler() http.Handler {
	if p.uiHandler == nil {
		p.uiHandler = NewSwaggerUIHandler("/docs/swagger.json")
	}
	return p.uiHandler
}

// Endpoints returns the documentation endpoints
func (p *SwaggerProvider) Endpoints() map[string]http.Handler {
	endpoints := make(map[string]http.Handler)
	
	// JSON endpoint
	endpoints["/docs/swagger.json"] = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.Write(p.swaggerJSON)
	})
	
	// UI endpoint
	endpoints["/docs"] = p.UIHandler()
	endpoints["/docs/"] = p.UIHandler()
	
	return endpoints
}

// addRoute adds a route to the Swagger documentation
func (p *SwaggerProvider) addRoute(route doc.RouteInfo) {
	// Get or create path item
	pathItem, exists := p.swagger.Paths[route.Path]
	if !exists {
		pathItem = &PathItem{}
		p.swagger.Paths[route.Path] = pathItem
	}

	// Create operation
	operation := &Operation{
		Summary:     route.Description,
		Description: route.Description,
		OperationID: p.generateOperationID(route),
		Tags:        route.Tags,
		Parameters:  p.extractParameters(route),
		Responses:   p.generateResponses(route),
	}

	// Add metadata
	if group, ok := route.Metadata["group"].(string); ok && group != "" {
		operation.Tags = append(operation.Tags, group)
	}

	// Set operation based on method
	switch strings.ToUpper(route.Method) {
	case "GET":
		pathItem.Get = operation
	case "POST":
		pathItem.Post = operation
		// Add request body for POST
		operation.RequestBody = p.generateRequestBody(route)
	case "PUT":
		pathItem.Put = operation
		operation.RequestBody = p.generateRequestBody(route)
	case "DELETE":
		pathItem.Delete = operation
	case "PATCH":
		pathItem.Patch = operation
		operation.RequestBody = p.generateRequestBody(route)
	case "HEAD":
		pathItem.Head = operation
	case "OPTIONS":
		pathItem.Options = operation
	}
}

// generateOperationID generates a unique operation ID
func (p *SwaggerProvider) generateOperationID(route doc.RouteInfo) string {
	// Use handler name if available
	if route.Handler != "" {
		return strings.ReplaceAll(route.Handler, ".", "_")
	}
	
	// Generate from method and path
	path := strings.ReplaceAll(route.Path, "/", "_")
	path = strings.ReplaceAll(path, ":", "")
	path = strings.ReplaceAll(path, "{", "")
	path = strings.ReplaceAll(path, "}", "")
	return strings.ToLower(route.Method) + path
}

// extractParameters extracts parameters from the route path
func (p *SwaggerProvider) extractParameters(route doc.RouteInfo) []Parameter {
	params := []Parameter{}
	
	// Extract path parameters
	parts := strings.Split(route.Path, "/")
	for _, part := range parts {
		if strings.HasPrefix(part, ":") {
			paramName := strings.TrimPrefix(part, ":")
			params = append(params, Parameter{
				Name:        paramName,
				In:          "path",
				Required:    true,
				Description: fmt.Sprintf("Path parameter: %s", paramName),
				Schema: &Schema{
					Type: "string",
				},
			})
		}
	}
	
	// Add documented parameters
	for _, param := range route.Params {
		p := Parameter{
			Name:        param.Name,
			In:          param.Type,
			Required:    param.Required,
			Description: param.Description,
			Schema: &Schema{
				Type: param.DataType,
			},
		}
		
		if param.Example != "" {
			p.Example = param.Example
		}
		
		params = append(params, p)
	}
	
	return params
}

// generateResponses generates standard responses
func (p *SwaggerProvider) generateResponses(route doc.RouteInfo) map[string]*Response {
	responses := make(map[string]*Response)
	
	// Success response
	responses["200"] = &Response{
		Description: "Successful response",
		Content: map[string]*MediaType{
			"application/json": {
				Schema: &Schema{
					Type: "object",
				},
			},
		},
	}
	
	// Error responses
	responses["400"] = &Response{
		Description: "Bad request",
		Content: map[string]*MediaType{
			"application/json": {
				Schema: &Schema{
					Ref: "#/components/schemas/Error",
				},
			},
		},
	}
	
	responses["500"] = &Response{
		Description: "Internal server error",
		Content: map[string]*MediaType{
			"application/json": {
				Schema: &Schema{
					Ref: "#/components/schemas/Error",
				},
			},
		},
	}
	
	return responses
}

// generateRequestBody generates request body for POST/PUT/PATCH
func (p *SwaggerProvider) generateRequestBody(route doc.RouteInfo) *RequestBody {
	return &RequestBody{
		Description: "Request body",
		Required:    true,
		Content: map[string]*MediaType{
			"application/json": {
				Schema: &Schema{
					Type: "object",
				},
			},
		},
	}
}

// generateCommonSchemas generates common schema definitions
func (p *SwaggerProvider) generateCommonSchemas() {
	// Error schema
	p.swagger.Components.Schemas["Error"] = &Schema{
		Type: "object",
		Properties: map[string]*Schema{
			"code": {
				Type:        "integer",
				Description: "Error code",
			},
			"message": {
				Type:        "string",
				Description: "Error message",
			},
			"details": {
				Type:        "object",
				Description: "Additional error details",
			},
		},
		Required: []string{"code", "message"},
	}
}