package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// HandlerTemplate is the template for generating HTTP handlers
const handlerTemplate = `// Code generated by gortex-gen. DO NOT EDIT.

package {{.Package}}

import (
	"net/http"
	{{- range .Imports}}
	{{.Alias}} "{{.Path}}"
	{{- end}}
)

// {{.HandlerName}} is the HTTP handler for {{.StructName}}.{{.MethodName}}
type {{.HandlerName}} struct {
	service *{{.ServicePackage}}.{{.StructName}}
	{{- if .NeedsBinder}}
	binder  *app.ParameterBinder
	{{- end}}
}

// New{{.HandlerName}} creates a new {{.HandlerName}} instance
func New{{.HandlerName}}(service *{{.ServicePackage}}.{{.StructName}}{{if .NeedsBinder}}, binder *app.ParameterBinder{{end}}) *{{.HandlerName}} {
	return &{{.HandlerName}}{
		service: service,
		{{- if .NeedsBinder}}
		binder:  binder,
		{{- end}}
	}
}

{{- range .Routes}}

// {{.HTTPMethod}} handles {{.HTTPMethod}} {{.Pattern}}
func (h *{{$.HandlerName}}) {{.HTTPMethod}}(c echo.Context) error {
	{{- if .HasRequestStruct}}
	
	// Bind request
	var req {{.RequestType}}
	if err := h.binder.Bind(c, &req); err != nil {
		return response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", "Invalid request parameters", err.Error())
	}
	{{- end}}
	
	{{- if .PathParams}}
	// Extract path parameters
	{{- range .PathParams}}
	{{.Name}} := c.Param("{{.ParamName}}")
	{{- if eq .Type "int"}}
	{{.Name}}Int, err := strconv.Atoi({{.Name}})
	if err != nil {
		return response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", "Invalid {{.ParamName}}", err.Error())
	}
	{{- end}}
	{{- end}}
	{{- end}}
	
	// Call service method
	{{- if .HasResults}}
	{{.ResultVars}} := h.service.{{.MethodName}}({{range $i, $arg := .ServiceArgs}}{{if $i}}, {{end}}{{$arg}}{{end}})
	{{- else}}
	err := h.service.{{.MethodName}}({{range $i, $arg := .ServiceArgs}}{{if $i}}, {{end}}{{$arg}}{{end}})
	{{- end}}
	
	{{- if .ReturnsError}}
	if err != nil {
		// Use error registry to map business errors to HTTP errors
		httpStatus, errResp := errors.HandleBusinessError(err)
		if errResp != nil {
			return errResp.Send(c, httpStatus)
		}
		// Fallback to generic error
		return response.Error(c, http.StatusInternalServerError, "INTERNAL_ERROR", "Service error", err.Error())
	}
	{{- end}}
	
	{{- if .HasNonErrorResult}}
	// Return success response
	return response.Success(c, http.StatusOK, {{.SuccessData}})
	{{- else}}
	// Return success response
	return response.Success(c, http.StatusOK, map[string]string{"status": "success"})
	{{- end}}
}
{{- end}}
`

// TemplateData holds data for the handler template
type TemplateData struct {
	Package         string
	HandlerName     string
	StructName      string
	MethodName      string
	ServicePackage  string
	NeedsBinder     bool
	Imports         []ImportInfo
	Routes          []RouteInfo
}

// ImportInfo represents an import statement
type ImportInfo struct {
	Alias string
	Path  string
}

// RouteInfo represents a route handler method
type RouteInfo struct {
	HTTPMethod        string
	Pattern           string
	MethodName        string
	HasRequestStruct  bool
	RequestType       string
	PathParams        []PathParam
	HasResults        bool
	ResultVars        string
	ServiceArgs       []string
	ReturnsError      bool
	HasNonErrorResult bool
	SuccessData       string
}

// PathParam represents a path parameter
type PathParam struct {
	Name      string
	ParamName string
	Type      string
}

// GenerateHandler generates the handler code for a service method
func GenerateHandler(spec HandlerSpec, methodInfo *MethodInfo) (string, error) {
	data := prepareTemplateData(spec, methodInfo)
	
	// Parse and execute template
	tmpl, err := template.New("handler").Parse(handlerTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}
	
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}
	
	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code for debugging
		return buf.String(), fmt.Errorf("failed to format generated code: %w", err)
	}
	
	return string(formatted), nil
}

// prepareTemplateData prepares the template data from handler spec and method info
func prepareTemplateData(spec HandlerSpec, methodInfo *MethodInfo) TemplateData {
	handlerName := spec.StructName + "Handler"
	
	// Collect imports
	imports := []ImportInfo{
		{"", "github.com/labstack/echo/v4"},
		{"", "github.com/yshengliao/gortex/pkg/response"},
		{"", "github.com/yshengliao/gortex/pkg/errors"},
	}
	
	// Check if we need the app package for binder
	needsBinder := hasRequestStruct(methodInfo)
	if needsBinder {
		imports = append(imports, ImportInfo{"", "github.com/yshengliao/gortex/app"})
	}
	
	// Check if we need strconv for parameter conversion
	if hasIntParams(methodInfo) {
		imports = append(imports, ImportInfo{"", "strconv"})
	}
	
	// Add service package import
	servicePackage := spec.PackageName
	if servicePackage != "handlers" {
		imports = append(imports, ImportInfo{"", fmt.Sprintf("github.com/yshengliao/gortex/internal/%s", servicePackage)})
	}
	
	// Create route info
	route := createRouteInfo(spec, methodInfo)
	
	return TemplateData{
		Package:        "handlers",
		HandlerName:    handlerName,
		StructName:     spec.StructName,
		MethodName:     spec.MethodName,
		ServicePackage: servicePackage,
		NeedsBinder:    needsBinder,
		Imports:        imports,
		Routes:         []RouteInfo{route},
	}
}

// createRouteInfo creates route information from method analysis
func createRouteInfo(spec HandlerSpec, methodInfo *MethodInfo) RouteInfo {
	route := RouteInfo{
		HTTPMethod:  methodInfo.HTTPMethod,
		Pattern:     GetRoutePattern(spec.MethodName),
		MethodName:  spec.MethodName,
	}
	
	// Check for request struct (non-context struct parameter)
	var requestParam *ParamInfo
	var serviceArgs []string
	
	for _, param := range methodInfo.Params {
		if param.Type == "echo.Context" || strings.HasSuffix(param.Type, ".Context") {
			serviceArgs = append(serviceArgs, "c.Request().Context()")
		} else if param.IsStruct && requestParam == nil {
			requestParam = &param
			route.HasRequestStruct = true
			route.RequestType = param.Type
			if param.IsPtr {
				serviceArgs = append(serviceArgs, "&req")
			} else {
				serviceArgs = append(serviceArgs, "req")
			}
		} else if param.Type == "string" {
			// Assume it's a path parameter
			pathParam := PathParam{
				Name:      param.Name,
				ParamName: param.Name,
				Type:      "string",
			}
			route.PathParams = append(route.PathParams, pathParam)
			serviceArgs = append(serviceArgs, param.Name)
		} else if param.Type == "int" {
			// Path parameter that needs conversion
			pathParam := PathParam{
				Name:      param.Name,
				ParamName: param.Name,
				Type:      "int",
			}
			route.PathParams = append(route.PathParams, pathParam)
			serviceArgs = append(serviceArgs, param.Name+"Int")
		} else {
			// Other parameters
			serviceArgs = append(serviceArgs, param.Name)
		}
	}
	
	route.ServiceArgs = serviceArgs
	
	// Handle results
	var nonErrorResults []string
	for _, result := range methodInfo.Results {
		if result.IsError {
			route.ReturnsError = true
		} else {
			nonErrorResults = append(nonErrorResults, fmt.Sprintf("result%d", len(nonErrorResults)))
		}
	}
	
	if len(nonErrorResults) > 0 {
		route.HasResults = true
		route.HasNonErrorResult = true
		route.ResultVars = strings.Join(nonErrorResults, ", ")
		if route.ReturnsError {
			route.ResultVars += ", err"
		}
		// Use the first non-error result as success data
		route.SuccessData = nonErrorResults[0]
	} else if route.ReturnsError {
		route.HasResults = true
		route.ResultVars = "err"
	}
	
	return route
}

// hasRequestStruct checks if the method has a request struct parameter
func hasRequestStruct(methodInfo *MethodInfo) bool {
	for _, param := range methodInfo.Params {
		if param.IsStruct && param.Type != "echo.Context" && !strings.HasSuffix(param.Type, ".Context") {
			return true
		}
	}
	return false
}

// hasIntParams checks if the method has integer parameters
func hasIntParams(methodInfo *MethodInfo) bool {
	for _, param := range methodInfo.Params {
		if param.Type == "int" {
			return true
		}
	}
	return false
}